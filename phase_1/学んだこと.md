# 今日の学びメモ（Terraform × GCP / Phase 1）

## 1) Terraform の基本ピースの役割

- **provider**：クラウドと会話する“通訳”。GCP なら `google` プロバイダを使う
- **resource**：実際に作る対象（例：`google_storage_bucket` = GCS バケット）
- **variables**：環境ごとに差し替える値の入口
- **outputs**：作成後に外へ見せたい“引き渡しメモ”（ID/名前/URL など）
- **locals**：命名規則や軽い計算をまとめる置き場
- **modules**：意図ごとの部品化（VPC/Cloud Run/Cloud SQL など）

## 2) API 有効化は `google_project_service`

- **目的**：Cloud Storage など各 GCP サービスは **API を ON** にしないと使えない
- **正しいリソース名**：`google_project_service`（※typo に注意）
- **順番が重要**：まず `serviceusage.googleapis.com`（Service Usage API）を ON にしないと、Storage など他 API の有効化操作が 403 で失敗する（初回だけはコンソールや `gcloud services enable` で手動有効化が必要）
- **例**（Storage API を ON にする）:

  ```hcl
  resource "google_project_service" "service_usage" {
    project = var.project_id
    service = "serviceusage.googleapis.com"
    disable_on_destroy = false
  }

  resource "google_project_service" "storage" {
    project = var.project_id
    service = "storage.googleapis.com"
    disable_on_destroy = false
    depends_on = [google_project_service.service_usage]
    # 本番でAPIを消したくない場合は安全策として：
    # disable_on_destroy = false
  }
  ```

- **理由**：手動 ON でも技術的には動くが、IaC に含めると**再現性が上がる**（新規プロジェクトでも自動で ON）
- **補足**：`terraform destroy` で API を自動停止しようとすると `cloudapis.googleapis.com` など依存サービスが原因で失敗するため、`disable_on_destroy = false` を付けて「削除時は ON のまま」にする

## 3) 依存関係は `depends_on` で明示

- バケットは **Storage API が有効**でないと作成失敗し得る
- リソース定義が直接参照していないため暗黙依存が働かない
- **初回 apply のレース回避**のため `depends_on` を付ける

  ```hcl
  resource "google_storage_bucket" "app_bucket" {
    name     = "${var.project_id}-phase1-bucket"
    location = var.region
    uniform_bucket_level_access = true

    depends_on = [google_project_service.storage]
  }
  ```

## 4) `output` は“公開インターフェース”（必須ではない）

- **用途**：

  - 手動確認を素早く：`terraform output bucket_name`
  - 他モジュール・後続ジョブへ値を渡す
  - CI のログや通知で可視化

- **例**：

  ```hcl
  output "bucket_name" {
    value = google_storage_bucket.app_bucket.name
    # 機微情報を出す場合は sensitive = true
  }
  ```

## 5) 実行コマンドの意味（復習）

- `init`：初期化（プロバイダ取得、バックエンド設定）
- `plan`：差分の見積り（安全確認の心臓部）
- `apply`：見積り通りに適用
- `destroy`：管理下のリソースを一括削除（検証環境の片付けで使用）

## 6) つまずきポイント（回避策）

- **typo**：`google_project_sercie` → `google_project_service`
- **API 未有効**：`google_project_service` で ON を明記
- **命名衝突**：GCS バケツ名は**グローバル一意**に
- **認証**：`gcloud auth application-default login`、`gcloud config set project ...` の確認

---

## 付録：今回の `main.tf`（解説コメントつき最小形）

```hcl
terraform {
  required_version = "~> 1.9"
  required_providers {
    google = { source = "hashicorp/google", version = "~> 6.0" }
  }
}

provider "google" {
  project = var.project_id   # どのGCPプロジェクトで動かすか
  region  = var.region       # 既定のリージョン
}

# Cloud Storage API をONにする（IaCで再現性を担保）
resource "google_project_service" "storage" {
  project = var.project_id
  service = "storage.googleapis.com"
  # disable_on_destroy = false   # 本番でAPIを消したくない場合の保険
}

# バケット本体（APIがONでないと初回に失敗し得るため依存を明示）
resource "google_storage_bucket" "app_bucket" {
  name                        = "${var.project_id}-phase1-bucket"  # 一意の名前に
  location                    = var.region
  uniform_bucket_level_access = true
  depends_on                  = [google_project_service.storage]    # 順序固定
}

# 出力は“引き渡しメモ”（人/CI/別モジュールが参照しやすい）
output "bucket_name" {
  value = google_storage_bucket.app_bucket.name
}
```

---

## 次の一歩（Phase 2 への橋渡し）

- この構成を **モジュール化**（`modules/bucket`）し、`environments/dev|prod` から **同じ部品を呼ぶ**形へ拡張
- 値の違いは `*.tfvars` に閉じ込めて、**同一設計 × 環境差分**を体で掴む
